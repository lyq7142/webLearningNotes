# 浏览器结构

用户界面（展示除标签页外的其它用户界面内容）
浏览器引擎（在用户界面和渲染引擎之间传递数据，数据持久层、cookie）
渲染引擎（渲染用户请求的页面内容，网络模块、js解释器）

* 浏览器的组成结构：
浏览器是运行在操作系统上的应用程序，每个应用程序至少启动一个进程执行功能，进程创建一些线程帮助其执行小任务。

**进程**是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。
**线程**是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

启动一个程序时，就会创建一个进程执行任务代码，同时为该进程分配内存空间，这个程序的状态都保存在内存空间里，应用关闭时，内存空间被回收。

进程可以启动更多进程执行任务，每个进程分配的内存空间是独立的，两个进程间通过**进程通信管道IPC**传递数据。很多程序是多进程结构，可以避免某一个进程卡死，不会影响整个应用程序。

进程可以将任务分成多个细小的任务，创建多个线程并行执行不同任务。同一进程下的线程可以直接通信共享数据。

* 多进程浏览器结构：（依据功能划分）
1.浏览器进程（控制除标签页之外的用户界面，地址栏、书签、前进、后退）
2.缓存进程
3.网络进程（发起、接受网络请求）
4.渲染器进程（控制显示tab标签内的所有内容）
5.GPU进程（负责浏览器界面的渲染）
6.插件进程（负责控制网站使用的所有插件，如flash，不是指chrome扩展）

浏览器默认为每个标签页创建一个进程，哪怕是同一个网站不同页面。

## 在浏览器地址栏输入内容时，浏览器内部会发生什么？

用户在地址栏输入地址时，浏览器进程的UI线程会捕捉输入的内容。
如果访问的是网址，UI线程会启动一个**网络线程**来请求DNS进行域名解析，再连接服务器获取数据。
如果输入的内容是一串关键词，会使用默认搜索引擎查询。

网络线程获取数据后，会发生什么？
首先，通过SafeBrowsing（谷歌站点安全系统）检查站点是否是恶意站点，提示警告页面，站点有安全问题，浏览器阻止用户进行访问。用户也可强行继续访问，当返回数据准备完毕并通过安全校验后，网络线程通知UI线程就要准备好了，UI线程创建一个渲染器进程来渲染页面。
浏览器进程通过IPC管道把数据传给渲染器进程，渲染器进程把数据（html css js 图片等资源）渲染成用户可交互的web页面。
渲染阶段：
渲染器进程的主线程解析html，构造DOM（文档对象模型[^DOM]）数据结构，html首先通过tokeniser标记化，通过词法分析将输入的html解析成多个标记，进行DOM树构造，会创建document对象，DOM进行修改、增添元素。
图片和CSS需要通过网络下载或从缓存中直接加载，不会影响DOM树的构建。
HTML解析过程中遇到script标签，就会停止html解析，转而去加载、解析并执行js。（因为浏览器不知道js的执行是否改变当前页面的HTML结构，比如document.write，因此开发中把js放在合适的位置，或者用async或defer属性来异步加载执行js）
html解析完成后，获得DOM Tree，主线程解析CSS，计算样式。
layout布局阶段：
节点的坐标以及需要占用页面多大区域。主线程遍历DOM和计算好的样式生成Layout Tree，layout tree上每个节点记录了x y坐标和边框尺寸。
（设置了display:none的节点不会出现在layout tree上；在before伪类的content中添加了内容的元素不会出现在DOM树中）
绘制阶段Paint：
z-index会影响节点绘制的层级关系，为了展示正确的层级，主线程遍历layout tree创建一个绘制记录表（Paint Record），记录了绘制的顺序。
栅格化（Rastering）[^栅格化]：转化为像素点显示在屏幕上。
主线程遍历layout tree，生成layer tree，主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，切割成多个图块（tiles），把每个图块发送给栅格化线程来栅格化，并存储在GPU内存中。图块栅格化完成后，合成器线程收集“draw quads”的图块信息，该信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，合成器线程生成一个合成器帧，帧通过IPC传递给浏览器进程，再把帧传送到GPU，再渲染展示到屏幕。
当用户滚动页面，会合成新的帧，传送GPU，再渲染到屏幕。

重排：改变元素位置尺寸属性时，会重新计算样式，布局，绘制等流程。
重绘：改变元素颜色属性，触发样式计算和绘制，不会重新布局。
重排、重绘、js都占用主线程，会出现抢占执行时间的问题，当页面以每秒60帧的刷新率时才不会让用户感到卡顿，当在一帧的时间内布局和绘制结束后，有剩余时间，js拿到主线程的使用权，如果执行时间过长，影响下一帧，出现卡顿。

优化手段：
1.requestAnimationFrame() 在每一帧被调用，通过API回调，将js运行任务分成更小的任务块到每一帧，
React渲染引擎---React Fiber 用api做优化

2.transform做动画

[^DOM]: 浏览器对页面在其内部的表现形式,web程序员可以通过js与之交互的数据结构和API

[^栅格化]: chrome早期栅格化方案（只栅格化用户可视区域viewport的内容，用户滚动页面时再继续栅格化更多内容）。现在使用合成（Composting）技术，将页面各部分分成多个图层，分别对其栅格化，并在合成器线程中单独进行合成页面的技术。
